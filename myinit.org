#+STARTUP: overview
* note
Since I always forget this, to bisect the emacs file for error, add this:
  : (error "Done")
* initial set up
** packages

#+BEGIN_SRC emacs-lisp
(setenv "PATH"
	(concat (getenv "PATH")
		":/usr/local/bin"))
(add-to-list 'exec-path "/usr/local/texlive/2016/bin/x86_64-darwin")

(require 'url-handlers)
(add-to-list 'load-path "/Users/michael/.emacs.d/el-get/org-opml/")

(add-to-list 'load-path "~/.emacs.d/lisp/")

;; load org file again
(global-set-key (kbd "C-c i")
                (lambda() (interactive)(org-babel-load-file "~/.emacs.d/myinit.org")))
#+END_SRC

** mac specific
#+BEGIN_SRC emacs-lisp
;; super vs shift key
;; - s = super
;; - S = shift

;; shell issues
;; is this needed for flyspell to work?
(when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize))

;; keys
(if (equal system-type 'darwin)
    (progn
      (setq mac-command-modifier 'super)
      (setq mac-option-modifier 'meta)
      (setq sentence-end-double-space nil)))

#+END_SRC

Open any new docs in the same emacs frame.

#+BEGIN_SRC emacs-lisp
;; (server-start)
(setq ns-pop-up-frames nil)
#+END_SRC

* manual installs
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/")

(load "org-devonthink")
#+END_SRC

* user interface tweaks
** general

Never, ever, ever accidentally close the emacsclient again!

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-w") 'kill-ring-save)
#+END_SRC

I am trying to steer away from =require=, but I think that this package doesn't have autoload cookies, hence the necessity to tell Emacs explicitely to load it.

#+BEGIN_SRC emacs-lisp
;; mouse like kitchin
(require 'org-mouse)
#+END_SRC

=fset= changes the function that the symbol points to. Essentially, whenever a package writer tries to call =yes-or-no-p=, Emacs will swap in the =y-or-n-p= function.

Tricksy.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)

(setq-default indent-tabs-mode nil)

;;preview files in dired
(use-package peep-dired
  :ensure t
  :config
  (setq peep-dired-cleanup-on-disable t)
  :bind (:map dired-mode-map
              ("P" . peep-dired)))

;; dired copy to other shown dired buffer
(setq dired-dwim-target t)

;; got to kill it
(global-set-key (kbd "C-<f5>") 'save-buffers-kill-emacs)
#+END_SRC

I've been getting locked pid's since switching to my new machine. Something's amiss, but rather than digging too deeply, I'm just going to have emacs stop worrying about lockfiles.

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

I'm trying to make better use of the mark ring to navigate. Here's some steps towards that.

#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

** visual
Just some tweaks here.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)

(setq visible-bell nil)

(when (window-system)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))

(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
            '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))

(blink-cursor-mode 1)

(add-to-list 'default-frame-alist
	     '(font . "Monaco"))

(set-face-attribute 'default nil :font "Monaco" :height 140)

;; make increasing size of text less carpal-tunnelish
(global-set-key (kbd "C-x C-=") 'text-scale-adjust)

;; for presenting in meetings
;;(set-face-attribute 'default nil :font "Monaco" :height 200)

(show-paren-mode 1)

;; (require 'delight)
;; (delight 'terraform-mode "TF")

;; no need for tabs
(setq-default indent-tabs-mode nil)

;; make cursor the width of the character it is under
;; i.e. full width of a TAB
(setq x-stretch-cursor t)

(use-package rainbow-delimiters
  :ensure t
  :defer t
  :init
  (progn
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode))
  :config
  (progn
    (set-face-foreground 'rainbow-delimiters-depth-1-face "snow4")
    (setf rainbow-delimiters-max-face-count 1)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error)
    (set-face-foreground 'rainbow-delimiters-depth-1-face "snow4")))

(setq-default indicate-buffer-boundaries 'left)
(setq-default indicate-empty-lines +1)

;; hide gibberish header from grep return
(defun mkm/delete-grep-header ()
  (save-excursion
    (with-current-buffer grep-last-buffer
      (goto-line 5)
      (narrow-to-region (point) (point-max)))))

;; (defadvice grep (after delete-grep-header activate) (mkm/delete-grep-header))
;; (defadvice rgrep (after delete-grep-header activate) (mkm/delete-grep-header))
#+END_SRC

Let's me jump back to frame layout that I'm using. 
#+BEGIN_SRC emacs-lisp
;; winner-mode for sanity
(winner-mode 1)

;; save my place
(save-place-mode 1)
#+END_SRC

** mark-multiple
I'm finally hopping aboard the train. I read that there's bugs, but I'll give it a shot.

#+BEGIN_SRC emacs-lisp
;;(define-key markdown-mode-map "\M-n" nil)
;;(define-key markdown-mode-map "\M-p" nil)

(use-package multiple-cursors
  :ensure t
  :bind (("M-n" . mc/mark-next-like-this)
         ("M-p" . mc/mark-previous-like-this)
         ("C-c a" . mc/mark-all-like-this)
         ("C-c e" . mc/edit-lines)))
#+END_SRC
* org
** base org
One new change I've added is that I absolutely *detest* how org repositions the page whenever you cycle visibility. I'm not sure whether this is something that I've added myself or if it's something that has always occurred and I'm just now noticing it. I'm trying to turn this off now.

Ok, fixed now. See the "kill tab optimize" below.
#+BEGIN_SRC emacs-lisp
(require 'org)

(setq org-directory "~/Documents/org")
(setq org-agenda-files (list "~/Documents/org/work"))

(setq org-replace-disputed-keys t)

(add-hook 'org-capture-mode-hook 'visual-line-mode)
(add-hook 'org-mode-hook 'visual-line-mode)

;; kill tab optimize
(remove-hook 'org-cycle-hook
             #'org-optimize-window-after-visibility-change)

;; make expand work after ellipsis
;;(setq org-special-ctrl-a/e t)

;; trying out cycling
(setq org-cycle-include-plain-lists t)
;; could not get this to run new mac
;;(require 'ox-confluence)

;;bind to key
(define-key org-mode-map (kbd "C-<") 'org-begin-template)
(global-set-key (kbd "C-<") 'org-begin-template)

(global-set-key (kbd "C-c l") 'org-store-link)

(setq org-adapt-indentation t)
(setq org-fast-selection-include-todo nil)
(setq org-log-into-drawer t)
(setq org-M-RET-may-split-line t)
(setq org-use-speed-commands t)

;; latex export settings
(add-to-list 'org-latex-packages-alist '("" "listings"))
(setq org-latex-listings t)

(setq org-latex-listings-options '(("breaklines" "true")))

(setq
 org-outline-path-complete-in-steps nil
 org-refile-use-outline-path 'file
 org-refile-targets  '((nil :maxlevel . 1) (org-agenda-files :maxlevel . 1))
 )


;; add my own refile target
(defun mkm/org-refile-in-file (&optional prefix)
  "Refile to a target with the current file."
  (interactive)
  (let ((org-refile-targets `(("work.org" :regexp . ".*p_.*$")("work.org" :todo . "PROJ")("work.org" :regexp . "* AOR.*$"))))
    (call-interactively 'org-refile)))

;; now, remap some shit
(add-to-list 'org-speed-commands-user '("w" call-interactively 'mkm/org-refile-in-file))
(add-to-list 'org-speed-commands-user '("W" call-interactively 'org-refile))
(add-to-list 'org-speed-commands-user '(("S" . (widen))))

        

;; fix priorities so non-assigned are after the rest
(setq org-lowest-priority ?E)
(setq org-default-priority ?E)

(setq-default org-src-fontify-natively t)

;; some org-mode wonder
(setq org-default-notes-file (concat org-directory "/work/inbox.org"))
;; (define-key global-map "\C-cc" 'org-capture)
(define-key global-map "\C-cc" 'org-capture)
(global-set-key (kbd "C-S-SPC") 'org-capture)

(setq org-goto-interface 'outline-path-completion
      org-goto-max-level 10)
(setq org-startup-folded t)
(setq org-startup-indented nil)

;; I *hate* this key combo!
(define-key org-mode-map (kbd "C-,") nil)

#+END_SRC

** org capture

This allows me to call up capture from anywhere on my mac. It uses a Keyboard Maestro key combo (s-C [space]) to start the capture.

#+BEGIN_SRC emacs-lisp
(defadvice org-switch-to-buffer-other-window
    (after supress-window-splitting activate)
  "Delete the extra window if we're in a capture frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-other-windows)))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defun activate-capture-frame ()
  "run org-capture in capture frame"
  (select-frame-by-name "capture")
  (switch-to-buffer (get-buffer-create "*scratch*"))
  (org-capture)) 

(defadvice org-capture-select-template 
    (around delete-capture-frame activate)
  "Advise org-capture-select-template to close the frame on abort"
  (unless (ignore-errors ad-do-it t)
    (setq ad-return-value "q"))
  (if (and
       (equal "q" ad-return-value)
       (equal "capture" (frame-parameter nil 'name)))
      (delete-frame)))
#+END_SRC
** org blocks

I just grabbed this from practicemacs.

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun org-begin-template ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

;;bind to key
(define-key org-mode-map (kbd "s-<") 'org-begin-template)

#+END_SRC
** todo-based
These are specific for to do list work with org. I think I'm switching back.

This first bit needs special discussion because I keep forgetting to use it. This archives off all done tasks in the subtree, even nested, and without that stupid prompt. This needs to be mapped to a key!

#+BEGIN_SRC emacs-lisp
;; show tasks archived off into separate file in the agenda log
(setq org-agenda-archives-mode t)

;; just archive DONE and CANCELLED entries
(defun mkm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/+DONE|+CANCELLED" 'tree))

(global-set-key (kbd "s-a") 'mkm/org-archive-done-tasks)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'org-agenda)

(setq org-agenda-log-mode-items '(clock closed))

(setq org-log-done 'time)

;; to speed up agenda
(setq org-agenda-dim-blocked-tasks nil)
(setq org-agenda-inhibit-startup t)
(setq org-agenda-use-tag-inheritance nil)

(setq org-enforce-todo-checkbox-dependencies t)

(setq org-todo-keywords
           '((sequence "NEXT(n)" "TODO(t)" "PROJ(p)" "WAITING(w)" "|" "DONE(d!)")
             (sequence "SOMEDAY(s)" "|" "CANCELLED(c)")))

(setq org-tag-alist '(("maint" . ?m)("support" . ?s)
                      (:newline . nil)
                      ("admin" . ?a)("devops" . ?d)
                      (:newline . nil)
                      ("monitor" . ?M)("out" . ?o)("train" . ?t)
                      (:newline . nil)
                      ("camp" . ?c)("@dconnect" . ?D)
                      (:newline . nil)
                      ("home" . ?H)("learning" . ?L)("tools" . ?T)
))

;; archive cancelled tasks
(setq org-todo-state-tags-triggers '(("CANCELLED" ("ARCHIVE" . t))))

(setq org-agenda-custom-commands
      '(("c" "Chooser"
         (
          (tags-todo "-learning&-home&-tools/!NEXT|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-overriding-header "Current Tasks:")))
          (tags-todo "-learning&-home&-tools/!TODO|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-overriding-header "Task Pool:")))))
        ("w" "Work"
         (
          (tags-todo "-home&-tools&-learning/!NEXT|WAITING|SOMEDAY"
                     ((org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Current Tasks:")))
          (tags-todo "-home&-tools&-learning&LEVEL=2/PROJ"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Active Projects:")))
          (agenda "" ((org-agenda-span 1)))
          (tags-todo "-learning&-home&-tools/!WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-waiting-projects)
                      (org-agenda-overriding-header "Waiting Tasks:")))
          (tags-todo "-learning&-home&-tools&+{^p_.*}&LEVEL=2/WAITING"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Projects (Waiting):")))
          (tags-todo "-admin&-learning&-home&-tools/!TODO|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-overriding-header "Task Pool:")))))
        ("h" "Home"
         (
          (tags-todo "home|learning|tools/!NEXT|WAITING|SOMEDAY"
                     ((org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Current:")))
          (tags-todo "home|learning|tools&LEVEL=2/PROJ"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Active Projects:")))
          (tags-todo "learning/!TODO|WAITING|SOMEDAY"
                     ((org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Learning:")))
          (tags-todo "tools/!TODO|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-overriding-header "Tools:")))
          (tags-todo "home/!TODO|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-overriding-header "Home:")))
          (tags-todo "home|learning|tools/!WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-waiting-projects)
                      (org-agenda-overriding-header "Waiting Tasks:")))))
        ("p" "Project View"
          (
          (tags-todo "-learning&-home&-tools&LEVEL=2/PROJ"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Active Projects:")))
          (tags-todo "-learning&-home&-tools&+{^p_.*}&LEVEL=2/WAITING"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-overriding-header "Waiting Projects:")))
          (tags-todo "-learning&-home&-tools&+{^p_.*}&LEVEL=2/SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-overriding-header "Someday Projects:")))
          (tags-todo "-learning&-home&-tools/!NEXT|WAITING|SOMEDAY"
                     ((org-agenda-prefix-format "%-16:c%?-12t% s")
                      (org-agenda-sorting-strategy '(todo-state-up priority-down))
                      (org-agenda-skip-function 'my-skip-inside-waits)
                      (org-agenda-overriding-header "Current Tasks:")))))))

;; add a function to skip projects in the waiting tasks
;; if level 2 and have p_ tag, it's not a task but a project
(defun my-skip-projects ()
  (let (beg end m)
    (org-back-to-heading t)
    (setq beg (point)
          end (progn (outline-next-heading) (1- (point))))
    (goto-char beg)
    (setq alltags (prin1-to-string (org-get-tags-at)))
    (goto-char beg)
    (if (and (string-match "p_.*" alltags)
             (= (org-current-level) 2))
        end)))

(defun my-skip-waiting-projects ()
  (let (subtree-end beg end)
    (setq beg (point)
          end (progn (outline-next-heading) (1- (point))))
    (goto-char beg)
    (setq subtree-end (save-excursion (org-end-of-subtree t)))
    (if (not (or (re-search-forward "SOMEDAY.*" end t)
                 (and (re-search-forward ":p_.*" subtree-end t)
                      (= (org-current-level) 2))))
        nil
      subtree-end)))

;; I want to skip processing nested entries
;; when current heading is WAITING or SOMEDAY
;; also skip all projects converted to W or S
(defun my-skip-inside-waits ()
  (let (subtree-end beg end)
        (setq beg (point)
              end (progn (outline-next-heading) (1- (point))))
        (goto-char beg)
        (setq alltags (prin1-to-string (org-get-tags-at)))
        (goto-char beg)
        (setq subtree-end (save-excursion (org-end-of-subtree t)))
        (if (not (or (re-search-forward "WAITING.*" end t)
                     (re-search-forward "SOMEDAY.*" end t)
                     (and (string-match "p_.*" alltags)
                          (= (org-current-level) 2))))
            nil
          subtree-end)))

;; don't show waiting inside projects that are someday/waiting
;; also skip all projects converted to W or S
(defun my-skip-nested-waits ()
  (let (subtree-end beg end)
        (setq beg (point)
              end (progn (outline-next-heading) (1- (point))))
        (goto-char beg)
        (setq alltags (prin1-to-string (org-get-tags-at)))
        (goto-char beg)
        (setq subtree-end (save-excursion (org-end-of-subtree t)))
        (if (not (or (re-search-forward "WAITING.*" end t)
                     (re-search-forward "SOMEDAY.*" end t)
                     ;; ignore projects
                     (and (string-match "p_.*" alltags)
                          (= (org-current-level) 2))))
            nil
          subtree-end)))
#+END_SRC

** capture templates
I use these more than any other org feature. I think it needs to be pruned a bit.

#+BEGIN_SRC emacs-lisp
;; ;; my own templates -- screw automation!
(setq org-capture-templates
      '(
	("j" "Journal Entry"
	 entry (file+datetree "~/Documents/org/work/journal.org")
	 "* %?\n\n\n%i\n"
	 :empty-lines 1
	 )
	("p" "Personal Entry"
	 entry (file+datetree "~/Documents/org/personal/personal.org")
	 "* %?\n\n\n%i\n"
	 :empty-lines 1
	 )
	("h" "Home Entry"
	 entry (file+datetree "~/Documents/org/personal/home.org")
	 "* %?\n\n\n%i\n"
	 :empty-lines 1
	 )
	("i" "inbox - Home"
         entry (file+headline "~/Documents/org/personal/todo.org" "INBOX")
	 "* TODO %?")
	("f" "Fiction Entry"
	 entry (file+datetree "~/Documents/org/fiction/fiction.org")
	 "* %?\n\n\n%i\n"
	 :empty-lines 1
	 )
	("e" "Emacs"
	 entry (file "~/Documents/org/work/emacs.org")
	 "* %?\n%i\n\n"
         :empty-lines 1
         )
	("r" "Research"
	 entry (file+headline "~/Documents/org/work/topics.org" "topic inbox")
	 "** %?"
         )
	("R" "Research with copy"
	 entry (file+headline "~/Documents/org/work/topics.org" "topic inbox")
	 "** %?\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n"
         )
	("x" "Linux Entry"
	 entry (file+olp "~/Documents/org/work/notes/linux.org" "General")
	 "* %?\n%i\n\n")
	("c" "Chef"
	 entry (file+headline "~/Documents/org/work/notes/chef.org" "Notes")
	 "** %?")
	("E" "E" entry
	 (file+headline"~/Documents/org/personal/eros.org" "Notes")
	 "* %?\n\n\n%i\n"
	 :empty-lines 1)
	("t" "Todo" entry
	 (file+headline "~/Documents/org/work/work.org" "AOR INBOX")
	 "* TODO %?")
        ("d" "Diary" entry (file+datetree "~/Documents/org/work/diary.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
	))
#+END_SRC

** drag and drop
This from John Kitchin. Works well, when I remember to use it.

#+BEGIN_SRC emacs-lisp
;; drag and drop!
;; from http://kitchingroup.cheme.cmu.edu/blog/2015/07/10/Drag-images-and-files-onto-org-mode-and-insert-a-link-to-them/#disqus_thread

(defun my-dnd-func (event)
  (interactive "e")
  (goto-char (nth 1 (event-start event)))
  (x-focus-frame nil)
  (let* ((payload (car (last event)))
         (type (car payload))
         (fname (cadr payload))
         (img-regexp "\\(png\\|jp[e]?g\\)\\>"))
    (cond
     ;; insert image link
     ((and  (eq 'drag-n-drop (car event))
            (eq 'file type)
            (string-match img-regexp fname))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; insert image link with caption
     ((and  (eq 'C-drag-n-drop (car event))
            (eq 'file type)
            (string-match img-regexp fname))
      (insert "#+ATTR_ORG: :width 300\n")
      (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; C-drag-n-drop to open a file
     ((and  (eq 'C-drag-n-drop (car event))
            (eq 'file type))
      (find-file fname))
     ((and (eq 'M-drag-n-drop (car event))
           (eq 'file type))
      (insert (format "[[attachfile:%s]]" fname)))
     ;; regular drag and drop on file
     ((eq 'file type)
      (insert (format "[[%s]]\n" fname)))
     (t
      (error "I am not equipped for dnd on %s" payload)))))


(define-key org-mode-map (kbd "<drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<C-drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<M-drag-n-drop>") 'my-dnd-func)
#+END_SRC

** clocking
First, I need to make the clocking persist across reboots and restarts:

#+BEGIN_SRC emacs-lisp
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
#+END_SRC

I'm trying to return to this again. Let's see how long things last!

Most of this is lifted directly from http://doc.norang.ca/org-mode.html

Disabling this for now, very severe cpu spikes.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f9> i") 'bh/punch-in)
(global-set-key (kbd "<f9> o") 'bh/punch-out)

;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)

;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))

;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)

;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)

;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)

;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)

(setq bh/keep-clock-running nil)

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))


(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
      ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out)))


(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "21599c7d-2957-49c3-bdb0-aaf41914eaa6")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+END_SRC
* flyspell
This screws me up enough to merit its own section.

#+BEGIN_SRC emacs-lisp
(use-package ispell
  :defer 15
  :config
  (progn
    (cond
     ((executable-find "aspell")
      (setq ispell-program-name "aspell")
      (setq ispell-extra-args   '("--sug-mode=ultra"
                                  "--lang=en_US")))
     ((executable-find "hunspell")
      (setq ispell-program-name "hunspell")
      (setq ispell-extra-args   '("-d en_US"))))

    ;; Save a new word to personal dictionary without asking
    (setq ispell-silently-savep t)

    (use-package flyspell
      :diminish flyspell-mode
      :init
      (progn
        (setq flyspell-use-meta-tab nil)
        ;; Binding for `flyspell-auto-correct-previous-word'
        (setq flyspell-auto-correct-binding (kbd "C-S-j")))
      :config
      (progn
        ;; Stop flyspell overriding other key bindings
        (define-key flyspell-mode-map (kbd "C-,") nil)
        (define-key flyspell-mode-map (kbd "C-.") nil))
        ;; (global-set-key (kbd "<f12>") 'flyspell-mode))

        (add-hook 'prog-mode-hook #'flyspell-prog-mode)
        (with-eval-after-load 'auto-complete
          (ac-flyspell-workaround))
        ;; https://github.com/larstvei/dot-emacs#flyspell
        ;;(add-hook 'text-mode-hook #'turn-on-flyspell)
        ;;(add-hook 'org-mode-hook  #'turn-on-flyspell)

        ;; Flyspell signals an error if there is no spell-checking tool is
        ;; installed. We can advice `turn-on-flyspell' and `flyspell-prog-mode'
        ;; to try to enable flyspell only if a spell-checking tool is available.
        (defun modi/ispell-not-avail-p (&rest args)
          "Return `nil' if `ispell-program-name' is available; `t' otherwise."
          (not (executable-find ispell-program-name)))
        (advice-add 'turn-on-flyspell   :before-until #'modi/ispell-not-avail-p)
        (advice-add 'flyspell-prog-mode :before-until #'modi/ispell-not-avail-p))))
(provide 'setup-spell)
#+END_SRC
* themes
The way I am using themes is by defining the value of =my:theme=. Once I do that and restart emacs, everything magically works.

#+BEGIN_SRC emacs-lisp
;; current
;;(defvar my:theme 'zenburn)
;; for day
;; (defvar my:theme 'sanityinc-tomorrow-bright)
;; (defvar my:theme 'zenburn-hc)

;; for night
;; (defvar my:theme 'sanityinc-solarized-light)
;; (defvar my:theme 'sanityinc-tomorrow-day)
;; (defvar my:theme 'github)
;;(defvar my:theme 'github-modern)
(defvar my:theme 'adwaita)
;; (defvar my:theme 'sanityinc-tomorrow-eighties)
;; (defvar my:theme 'sanityinc-tomorrow-night)
;; mkm Wednesday, August 21, 2019
;; (defvar my:theme 'autumn-light)  
;; (defvar my:theme 'zenburn)
;; (defvar my:theme 'spacemacs-light)
;; (defvar my:theme 'zenburn)
#+END_SRC
** previous choices
**** specific themes
Here are theme's I've tried and why they did or didn't work:

Some darks:
- sanityinc-tomorrow-eighties: nice dark theme
- zenburn: made a tweak to see if I can set and reuse my:theme from this location in init.

Some lights:
- adwaita: pinks! not good; horrible todo headings
- autumn-light: this is looking good
  - not liking the magit diff
  - gutter is solid color, hm, not so good
- eziam: ugh
  - horrible colors
  - oversized shit from Leuven
- flatui -- out of date
- github-modern: current winner, but there's issues with some org agenda settings
- github: good, but not against bright window -- is this different than modern?
- gruvbox has too garish brights
- Leuven: Ugh, changed my mind
- material-light : just icky.
  - all the oversized crap from Leuven
  - some funky color choices
- minimal-light: so far, this is rocking it! -- eh, maybe not
- monokai t)
- sanityinc-tomorrow-day: too Xmas
  - awful git diff
- soft-stone t)
- tao-yang: not enough contrast
- twilight-bright t)

**** github-modern mods
My current choice, but needs some tweaking

#+BEGIN_SRC emacs-lisp
;;(setq github-override-colors-alist
;;      '(("github-selection" . "#ffc04c")))
#+END_SRC

**** zenburn
zenburn is ok for now, but I prefer a lighter theme. Should I switch back to Leuven?

#+BEGIN_SRC emacs-lisp
;; (use-package zenburn-theme
;;   :ensure t
;;   :config (load-theme 'zenburn t))
#+END_SRC

** scaffolding

I was a *bit* confused by the use of intern. Explanation: when you get the string from the minibuffer, it's just a string, not pointing to anything. By interning it, you get the symbol to which it points, which you then pass back as the output of the interactive macro into the function argument.

And the use of mapcar is to loop over all of the custom-enabled themes, disabling them. Remember, you have to use the =#= notation to clue the emacs compiler into the fact that "disable-theme" is a function (and should be checked for existence) and not just a string.

#+BEGIN_SRC emacs-lisp
(defun load-only-theme ()
  "Disable all themes and then load a single theme interactively."
  (interactive)
  (while custom-enabled-themes
    (disable-theme (car custom-enabled-themes)))
  (call-interactively 'load-theme))

(global-set-key (kbd "C-<f12>") 'switch-theme)

(defun switch-theme (theme)
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapcar 'symbol-name
                                     (custom-available-themes))))))
  (mapcar #'disable-theme custom-enabled-themes)
  (load-theme theme t))

;; disabled Saturday, May 19, 2018
;; (use-package apropospriate-theme
;;   :ensure t
;;   :init
;;   (custom-set-faces
;;    '(org-level-1 ((t :height 1.0 )))
;;    '(org-level-2 ((t :height 1.0 )))
;;    '(org-level-3 ((t :height 1.0 )))
;;    )
;;   :config 
;;   (load-theme 'apropospriate-light t)
;;   )

;; some stuff I'm trying mkm Friday, May 18, 2018)
;; (use-package color-theme
;;  :ensure t)
#+END_SRC

** fix for loading as a daemon

When running as a daemon, some themes don't seem to want to load when restarting. Hopefully the following will help:

#+BEGIN_SRC emacs-lisp
;; theme

;; need to set my theme wherever I set the main theme
;; (defvar my:theme 'github-modern)
(defvar my:theme-window-loaded nil)
(defvar my:theme-terminal-loaded nil)

(if (daemonp)
    (add-hook 'after-make-frame-functions(lambda (frame)
                       (select-frame frame)
                       (if (window-system frame)
                           (unless my:theme-window-loaded
                             (if my:theme-terminal-loaded
                                 (enable-theme my:theme)
                               (load-theme my:theme t))
                             (setq my:theme-window-loaded t))
                         (unless my:theme-terminal-loaded
                           (if my:theme-window-loaded
                               (enable-theme my:theme)
                             (load-theme my:theme t))
                           (setq my:theme-terminal-loaded t)))))

  (progn
    (load-theme my:theme t)
    (if (display-graphic-p)
        (setq my:theme-window-loaded t)
      (setq my:theme-terminal-loaded t))))
#+END_SRC

* highlight-indentation

#+BEGIN_SRC emacs-lisp
(require 'highlight-indentation)

(defun mkm/show-lines ()
  "Toggle `highlight-indentation-mode and `highlight-indentation-current-column-mode."
  (interactive)
  (highlight-indentation-mode)
  (highlight-indentation-current-column-mode))

(global-set-key (kbd "<f10>") 'highlight-indentation-current-column-mode)
(global-set-key (kbd "<f11>") 'highlight-indentation-mode)
#+END_SRC

* ivy

First, a tweak to selection. I'm not too hip on what ivy is doing here with the multip matches, but this gets me so I can read stuff again in the minibuffer. Currently, this is commented out, as I'm experimenting with themes -- again :(

#+BEGIN_SRC emacs-lisp
;; (custom-set-faces
;;  '(ivy-minibuffer-match-face-1 ((t (:background "#D3D3E3"))))
;;  '(ivy-minibuffer-match-face-2 ((t (:background "#f2f3d3"))))
;;  '(ivy-minibuffer-match-face-3 ((t (:background "#f2f3d3"))))
;;  '(ivy-minibuffer-match-face-4 ((t (:background "#f2f3d3"))))
;;  '(ivy-highlight-face ((t (:background "#f2f3d3"))))
;;  '(ivy-current-match ((t (:background "#b3ffb3")))))
#+END_SRC

* projectile
Adding ag

#+BEGIN_SRC emacs-lisp
(use-package ag :ensure t)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun mkm/projectile-mode-line ()
  "Report project name and type in the modeline."
  (let ((project-name (projectile-project-name)))
    (format " P:[%s]"
            project-name)))

(use-package projectile
  :ensure t
  :config
  (projectile-global-mode 1)
  (setq projectile-enable-caching t
        projectile-completion-system 'ivy
        projectile-mode-line-fn 'mkm/projectile-mode-line)
  :bind (("C-c p" . projectile-command-map)
         :map projectile-mode-map
         ("s-d" . projectile-find-dir)
         ("s-f" . projectile-find-file)
         ("s-g" . projectile-grep)))

(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-mode)
  :bind (("s-s" . counsel-projectile-ag)))

;; (projectile-mode +1)
;;(define-key projectile-mode-map (kbd "s-f") 'projectile-find-file)
;; (setq projectile-mode-line-fn (quote (:eval (format " bbb [%s]" (projectile-project-name)))))
;; (add-to-list 'projectile-globally-ignored-directories ".kitchen")
;; (add-to-list 'projectile-globally-ignored-files "#*.*#")
;; (add-to-list 'projectile-globally-ignored-files "*.DS_Store")

;; (setq projectile-indexing-method 'native)

;; ;; super key
;; (define-key global-map [?\s-d] 'projectile-find-dir)
;; (define-key global-map [?\s-f] 'projectile-find-file)
;; (define-key global-map [?\s-g] 'projectile-grep)

;; note: for iterm2, set alt to esc+

#+END_SRC

* ibuffer

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      '(("default"
         ("magit" (or
                   (name . "^.*magit.*:.*")))
         ("terraform" (name . ".*\\.tf"))
         ("markdown" (name . ".*\\.md"))
         ("yaml" (or
                  (name . ".*\\.yml")
                  (name . ".*\\.j2")
                  (name . ".*\\.yaml")))
         ("tramp" (or
                   (name . "^\\*tramp.*")
                   (filename . "^/sudo.*")
                   (filename . "^/ssh.*")))
         ("shell" (or
                   (mode . eshell-mode)
                   (mode . shell-mode)
                   (name . ".*\\.sh")))
         ("programming" (or
                         (mode . python-mode)
                         (mode . c++-mode)
                         (mode . perl-mode)
                         (mode . ruby-mode)
                         (name . ".*\\.ps1")))
         ("org" (name . "^.*org$"))
         ("emacs" (or
                   (name . "^\\*scratch\\*$")
                   (name . "^\\*Messages\\*$")
                   (name . "^\\*Help\\*$")
                   (name . ".*\\.el$")))
         ("web" (or (mode . web-mode) (mode . js2-mode)))
         ("dired" (mode . dired-mode))
         )))

(add-hook 'ibuffer-mode-hook
	  '(lambda ()
             (ibuffer-auto-mode 1)
             (ibuffer-switch-to-saved-filter-groups "default")))

;; Don't show filter groups if there are no buffers in that group
(setq ibuffer-show-empty-filter-groups nil)

;; Don't ask for confirmation to delete marked buffers
(setq ibuffer-expert t)

;; nearly all of this is the default layout
(setq ibuffer-formats 
      '((mark modified read-only " "
              (name 45 45 :left :elide) ; change: 30s were originally 18s
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " " filename-and-process)
        (mark " "
              (name 16 -1)
              " " filename)))
#+END_SRC

* markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))

(setq markdown-enable-wiki-links nil)
(setq markdown-hide-urls t)
(setq markdown-list-indent-width 4)

(setq markdown-open-command "~/bin/mark")
(setq markdown-indent-on-enter t)
(setq markdown-gfm-uppercase-checkbox t)
#+END_SRC

* git

#+BEGIN_SRC emacs-lisp
(use-package git-gutter+
  :ensure t
  :init (global-git-gutter+-mode)
  :diminish (git-gutter+-mode)
  :config
  (global-set-key (kbd "C-S-s") 'swiper)
  :bind (("C-x G" . git-gutter+-mode)
         ("C-x ." . git-gutter+-show-hunk-inline-at-point)
         :map git-gutter+-mode-map
         ("C-x C-n" . git-gutter+-next-hunk)
         ("C-x C-p" . git-gutter+-previous-hunk)))

;; mkm: turn back on for magit?
(use-package git-gutter+
  :ensure t
  :init (global-git-gutter+-mode)
  :diminish (git-gutter+-mode))

(global-set-key (kbd "C-x g") 'magit-status)
(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)

;; having issues with git-gutter not being updated post commit
(add-hook 'git-gutter:update-hooks 'magit-after-revert-hook)
(add-hook 'git-gutter:update-hooks 'magit-not-reverted-hook)

#+END_SRC

* indentation settings
#+BEGIN_SRC emacs-lisp
(require 'indent-tools)
(global-set-key (kbd "C-c >") 'mkm-indent-tools-hydra/body)

(require 'yafolding)

(defhydra mkm-indent-tools-hydra (:color red :hint nil)
  "
 ^Indent^         | ^Navigation^        | ^Actions^
------------------+---------------------+-----------
 _>_ indent       | _j_ v               | _i_ imenu
 _<_ de-indent    | _k_ ʌ               | _C_ Copy…
 _L_ end of level | _n_ next sibling    | _c_ comment
 _E_ end of fn    | _p_ previous sibling| _U_ uncomment (paragraph)
 _P_ paragraph    | _u_ up parent       | _f_ fold
 _SPC_ space      | _d_ down child      | _F_ fold all level
 ___ undo         | _e_ end of tree     | _q_ quit
"

  (">" indent-tools-indent)
  ("<" indent-tools-demote)
  ("E" indent-tools-indent-end-of-defun)
  ("c" indent-tools-comment)
  ("U" indent-tools-uncomment)
  ("P" indent-tools-indent-paragraph)
  ("L" indent-tools-indent-end-of-level)
  ("K" indent-tools-kill-tree)
  ("C" indent-tools-copy-hydra/body :color blue)
  ("s" indent-tools-select)
  ("e" indent-tools-goto-end-of-tree)
  ("u" indent-tools-goto-parent)
  ("d" indent-tools-goto-child)
  ("S" indent-tools-select-end-of-tree)
  ("n" indent-tools-goto-next-sibling)
  ("p" indent-tools-goto-previous-sibling)
  ("i" helm-imenu)
  ("j" forward-line)
  ("k" previous-line)
  ("SPC" indent-tools-indent-space)
  ("_" undo-tree-undo)
  ("l" recenter-top-bottom)
  ("f" yafolding-toggle-element)
  ("F" yafolding-toggle-all)
  ("q" nil)
  )
#+END_SRC

* Howard Abrams settings
** main

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Howard Abrams settings                                                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(setq initial-scratch-message "")
(setq visible-bell nil)

(when (window-system)
  (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  (scroll-bar-mode -1))           ;; Scrollbars waste screen estate
#+END_SRC

** window movement

This is the awesome stuff. Let's you move split windows using the arrow keys. It would be nice to be able to switch to a different window and start sizing from there . . . 

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :config
  (hydra-add-font-lock))

;; for hydra, below
(require 'windmove)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

(defhydra hydra-splitter (global-map "<f9>")
  "splitter"
  ("C-b" hydra-move-splitter-left)
  ("C-n" hydra-move-splitter-down)
  ("C-p" hydra-move-splitter-up)
  ("C-f" hydra-move-splitter-right))

;; (defhydra hydra-splitter (global-map "<f9>")
;;   "splitter"
;;   ("<left>" hydra-move-splitter-left)
;;   ("<down>" hydra-move-splitter-down)
;;   ("<up>" hydra-move-splitter-up)
;;   ("<right>" hydra-move-splitter-right))

#+END_SRC


** which key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :defer 10
  :diminish which-key-mode
  :config

  ;; Replacements for how KEY is replaced when which-key displays
  ;;   KEY → FUNCTION
  ;; Eg: After "C-c", display "right → winner-redo" as "▶ → winner-redo"
  (setq which-key-replacement-alist
        '((("<\\([[:alnum:]-]+\\)>") . ("\\1"))
          (("left")                  . ("◀"))
          (("right")                 . ("▶"))
          (("up")                    . ("▲"))
          (("down")                  . ("▼"))
          (("delete")                . ("DEL")) ; delete key
          (("\\`DEL\\'")             . ("BS")) ; backspace key
          (("next")                  . ("PgDn"))
          (("prior")                 . ("PgUp")))

        ;; List of "special" keys for which a KEY is displayed as just
        ;; K but with "inverted video" face... not sure I like this.
        which-key-special-keys '("RET" "DEL" ; delete key

                                 "ESC" "BS" ; backspace key
                                 "SPC" "TAB")

        ;; Replacements for how part or whole of FUNCTION is replaced:
        which-key-description-replacement-alist
        '(("Prefix Command" . "prefix")
          ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
          ("/body\\'"       . "") ; Remove display the "/body" portion of hydra fn names
          ("\\`projectile-" . "𝓟/")
          ("\\`hydra-"      . "+𝐇/")
          ("\\`org-babel-"  . "ob/"))

        ;; Underlines commands to emphasize some functions:
        which-key-highlighted-command-list
        '(("\\`hydra-" . which-key-group-description-face)
          "\\(rectangle-\\)\\|\\(-rectangle\\)")

        which-key-allow-multiple-replacements t)

  ;; Change what string to display for a given *complete* key binding
  ;; Eg: After "C-x", display "8 → +unicode" instead of "8 → +prefix"
  (which-key-add-key-based-replacements
    "C-x 8"   "unicode"
    "C-c T"   "toggles-"
    "C-c p s" "projectile-search"
    "C-c p 4" "projectile-other-buffer-"
    "C-x a"   "abbrev/expand"
    "C-x r"   "rect/reg"
    "C-c /"   "engine-mode-map"
    "C-c C-v" "org-babel")

  (which-key-mode 1))
#+END_SRC

* misc language settings
** language servers
I'm going to try and get the LSP server protocol to work. First, for Python.

MKM: Sunday, August 18, 2019
I've decided to try elpy first and then try lsp later, if needed.

MKM: Tuesday, August 20, 2019
Now going back to trying lsp

#+BEGIN_SRC emacs-lisp
;; works!
;; (use-package lsp-mode
;;   :ensure
;;   :config
;;   (add-hook 'python-mode-hook #'lsp))

;; fucking works!!!
(use-package lsp-python-ms
  :ensure t
  :hook (python-mode . (lambda ()
                         (require 'lsp-python-ms)
                         (lsp))))
(use-package flycheck)

(use-package lsp-ui
    :ensure t
    :config
    (setq lsp-ui-sideline-ignore-duplicate t)
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-use-childframe t)
    (setq lsp-ui-doc-use-webkit t)
    (setq lsp-ui-doc-background "#2e49b8")
    (setq lsp-ui-flycheck-enable t)
    (set-face-attribute 'lsp-ui-doc-background  nil :background "#f9f2d9")
    (add-hook 'lsp-mode-hook 'lsp-ui-mode)
    (add-hook 'python-mode-hook 'flycheck-mode))

(require 'lsp-ui-imenu)
  (add-hook 'lsp-after-open-hook 'lsp-enable-ui-imenu)

(define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
(define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)

(use-package company-lsp
  :ensure t
  :config
  (push 'company-lsp company-backends))

#+END_SRC
** yaml

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :defer t
  :config
  (add-hook 'yaml-mode-hook
            (lambda ()
              (setq-local paragraph-separate ".*>-$\\|[   ]*$")
              (setq-local paragraph-start paragraph-separate))))

#+END_SRC

** json

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :defer t
  :config
  (progn
    (setf json-reformat:pretty-string? t
          json-reformat:indent-width 2)
    (define-key json-mode-map (kbd "M-q")
      (lambda ()
        (interactive)
        (if (region-active-p)
            (call-interactively #'json-reformat-region)
          (json-reformat-region (point-min) (point-max)))))))
#+END_SRC

** python
As noted in the lsp section, I'm giving elpy a shot.


#+BEGIN_SRC emacs-lisp
;; (use-package elpy
;;   :ensure t
;;   :init
;;   (elpy-enable))

;; (when (load "flycheck" t t)
;;   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;   (define-key elpy-mode-map (kbd "C-c C-p") 'flycheck-previous-error)
;;   (define-key elpy-mode-map (kbd "C-c C-n") 'flycheck-next-error)
;;   (add-hook 'elpy-mode-hook 'flycheck-mode))

;; (add-hook 'python-mode-hook 'jedi:setup)
;; (setq jedi:setup-keys t)
;; (setq jedi:complete-on-dot t)


;; mkm Sunday, August 12, 2018
;; this should be resolved in my current emacs
;; remove if this is true

;; ;; to fix python
;; (with-eval-after-load 'python
;;   (defun python-shell-completion-native-try ()
;;     "Return non-nil if can trigger native completion."
;;     (let ((python-shell-completion-native-enable t)
;;           (python-shell-completion-native-output-timeout
;;            python-shell-completion-native-try-output-timeout))
;;       (python-shell-completion-native-get-completions
;;        (get-buffer-process (current-buffer))
;;        nil "_"))))
#+END_SRC

** terraform

Need to make this stop at undercore!

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode
  :ensure t
  :diminish terraform-mode
  :defer t)
#+END_SRC
** smart-parens
#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :diminish
  :config
  (progn
    (show-smartparens-global-mode t)))

(bind-keys
 :map smartparens-mode-map
 ("C-M-a" . sp-beginning-of-sexp)
 ("C-M-e" . sp-end-of-sexp)

 ("C-<down>" . sp-down-sexp)
 ("C-<up>"   . sp-up-sexp)
 ("M-<down>" . sp-backward-down-sexp)
 ("M-<up>"   . sp-backward-up-sexp)

 ("C-M-f" . sp-forward-sexp)
 ("C-M-b" . sp-backward-sexp)

 ("C-M-n" . sp-next-sexp)
 ("C-M-p" . sp-previous-sexp)

 ("C-S-f" . sp-forward-symbol)
 ("C-S-b" . sp-backward-symbol)

 ;; ("C-<right>" . sp-forward-slurp-sexp)
 ;; ("M-<right>" . sp-forward-barf-sexp)
 ;; ("C-<left>"  . sp-backward-slurp-sexp)
 ;; ("M-<left>"  . sp-backward-barf-sexp)

 ("C-M-t" . sp-transpose-sexp)
 ("C-M-k" . sp-kill-sexp)
 ("C-k"   . sp-kill-hybrid-sexp)
 ("M-k"   . sp-backward-kill-sexp)
 ("C-M-w" . sp-copy-sexp)
 ("C-M-d" . delete-sexp)

 ("M-<backspace>" . backward-kill-word)
 ("C-<backspace>" . sp-backward-kill-word)
 ([remap sp-backward-kill-word] . backward-kill-word)

 ("M-[" . sp-backward-unwrap-sexp)
 ("M-]" . sp-unwrap-sexp)

 ("C-x C-t" . sp-transpose-hybrid-sexp)

 ("C-c ("  . wrap-with-parens)
 ("C-c ["  . wrap-with-brackets)
 ("C-c {"  . wrap-with-braces)
 ("C-c '"  . wrap-with-single-quotes)
 ("C-c \"" . wrap-with-double-quotes)
 ("C-c _"  . wrap-with-underscores)
 ("C-c `"  . wrap-with-back-quotes))
#+END_SRC
* babel

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation nil 
      org-edit-src-content-indentation 0)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (ruby . t)
   (shell . t)
   (python . t)
   (ruby . t)
   (ditaa . t)))
#+END_SRC

* company-mode

Trying to add this back in. Not sure if I'll get it working to my satisfaction -- I didn't last time. Also, consider the following for avoiding clashes with yasnippet:
1. only enable yasnippet manually
2. restrict myself to 2-letter yasnippet commands and set company mode to 3
3. see about the other fixes outlined on reddit

#+BEGIN_SRC emacs-lisp
# (diminish 'yas--direct-terraform-mode)
# (use-package company
#   :diminish company-mode
#   :config
#   (setq company-idle-delay 0)
#   (setq company-minimum-prefix-length 3)
#   (global-set-key (kbd "C-<tab>") 'company-complete))

# (require 'company)
# (add-hook 'after-init-hook 'global-company-mode)

# (with-eval-after-load 'company
#   (define-key company-active-map (kbd "M-p") nil)
#   (define-key company-active-map (kbd "M-n") nil)
#   (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
#   (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)
#   (define-key company-active-map (kbd "SPC") nil)
#   (define-key company-active-map (kbd "S-SPC") 'company-abort))

# (require 'company-terraform)
# (company-terraform-init)
# #+END_SRC

* yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :ensure t
  :init
  (yas-global-mode 1))

(setq yas-snippet-dirs
      '("~/.emacs.d/snippets"))
#+END_SRC
* unfactored
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; editing                                                                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; adding back dired+
;; first, get quelpa
;; (use-package quelpa-use-package
;;   :init (setq quelpa-update-melpa-p nil))

;; (use-package dired+
;;   :quelpa (dired+ :fetcher url :url "https://www.emacswiki.org/emacs/download/dired+.el")
;;   :defer 1
;;   :init
;;   (setq diredp-hide-details-initially-flag nil)
;;   (setq diredp-hide-details-propagate-flag nil)

;;   :config
;;   (diredp-toggle-find-file-reuse-dir 1))

(use-package dired-subtree
  :config
  (bind-keys :map dired-mode-map
             ("i" . dired-subtree-insert)
             (";" . dired-subtree-remove))
  :init
  (setq dired-subtree-use-backgrounds nil))

(use-package dired-filter
  :ensure t)

(define-key dired-mode-map (kbd "/") dired-filter-map)

(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))

(use-package dired-collapse
  :ensure t
  :hook dired-mode)

;; rename function from Steve Yegge
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(global-set-key (kbd "C-c r") 'rename-this-buffer-and-file)

(defun mkm/fix-title()
  (interactive)
  (insert (replace-regexp-in-string " " "" (upcase-initials (org-entry-get nil "ITEM")))))

(global-set-key (kbd "C-c t") 'mkm/fix-title)
(global-set-key (kbd "C-s-f") 'counsel-ag)


;; no more lost files!
(defvar --backup-directory (concat user-emacs-directory "backups"))
(if (not (file-exists-p --backup-directory))
        (make-directory --backup-directory t))
(setq backup-directory-alist `(("." . ,--backup-directory)))
(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )
;; funky files name

(use-package counsel
  :bind
  (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

(setq counsel-git-cmd "rg --files")

(global-set-key [(control x) (control c)]
                (function
                 (lambda () (interactive)
                   (cond ((y-or-n-p "Quit? (save-buffers-kill-terminal) ")
                          (save-buffers-kill-terminal))))))

;; auto-revert mode
;; http://nhoffman.github.io/.emacs.d/#sec-3
(global-auto-revert-mode 1)
(setq auto-revert-verbose t)
(global-set-key (kbd "<f5>") 'revert-buffer)



;; fix for 'ls does not support --dired' message
(setq dired-use-ls-dired nil)

;;(use-package dired+
;;  :ensure t
;;  :diminish dired+-mode)

;; some editing extras
(use-package expand-region
  :ensure t
  :diminish expand-region-mode
  :bind(("C-=" . er/expand-region)))
        
;; (setq whole-line-or-region t)

(eval-after-load "fundamental-mode" '(diminish 'fundamental-mode))

(use-package avy
  :ensure t
  :diminish avy-mode
  :bind (("C-." . avy-goto-char-timer)))

(setq org-startup-with-inline-images t)

;; undo tree!
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (bind-keys*
   ("C-z" . undo-tree-undo)
   ("C-S-z" . undo-tree-redo))
  (global-undo-tree-mode 1)
  (setq undo-tree-mode t))

(defun my-diff-buffer-with-file ()
  "Compare the current modified buffer with the saved version."
  (interactive)
  (let ((diff-switches "-u")) ;; unified diff
    (diff-buffer-with-file (current-buffer))))

(global-set-key (kbd "C-z") nil)
(global-set-key (kbd "C-x =") 'my-diff-buffer-with-file)
(global-set-key (kbd "C-x C-=") 'ediff-current-file)

;;(require 'neotree)
;;(global-set-key (kbd "C-`") 'neotree-toggle)
(setq neo-smart-open t)

(use-package neotree
  :ensure t
  :bind (([f8] . neotree-toggle))
  :config (
           setq neo-smart-open t
                neo-autorefresh nil))

;; mkm make sure savehistory is working as intended
;; disabling so I can try session mode
(desktop-save-mode 1)
(savehist-mode 1)

;; recent files?
(require 'recentf)
(recentf-mode 1)
(global-set-key (kbd "C-x C-r") 'ivy-recentf)

;; let's add dates easier
(require 'calendar)
(defun insdate-insert-current-date (&optional omit-day-of-week-p)
  "Insert today's date using the current locale.
  With a prefix argument, the date is inserted without the day of
  the week."
  (interactive "P*")
  (insert (calendar-date-string (calendar-current-date) nil
                                omit-day-of-week-p)))

(global-set-key "\C-x\M-d" `insdate-insert-current-date)

;; (require 'ace-window)
(use-package ace-window
  :ensure t
  :init
  (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
  (global-set-key (kbd "C-x o") 'ace-window)
  :diminish ace-window-mode)

(use-package smooth-scrolling
  :ensure t
  :config (setq smooth-scroll-margin 2)
  :init (smooth-scrolling-mode 1))
(setq mouse-wheel-scroll-amount '(1 ((shift) .1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; tramp                                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(setq tramp-default-method "ssh")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ivy-mode                                                               ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package ivy
  :ensure t
  :diminish ivy-mode
  :bind
  ("C-c C-r" . ivy-resume)
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (global-set-key (kbd "C-S-s") 'swiper)
  (global-set-key (kbd "C-S-r") 'swiper)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "C-c C-r") 'ivy-resume)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-h v") 'counsel-describe-variable)
  (global-set-key (kbd "s-i") 'counsel-imenu )
  )

(global-set-key [f6] 'ivy-resume)
(setq magit-completing-read-function 'ivy-completing-read)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; zettelkasten                                                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; publish zettelkasten
(setq org-publish-project-alist
      '(("zk"
         :base-directory "~/Documents/org/zk/"
         :base-extension "org"
         :publishing-directory "~/Documents/org/my_pub/"
         :makeindex non-nil
         :auto-index t
         :section-numbers nil
         :with-author nil
         :with-date nil
         :auto-sitemap t
         :with-toc nil
         :with-properties t
         :with-title t
         :with-tags t
         :with-date nil
         :with-creator nil
         :with-email nil
         :with-timestamps t
         :html-validation-link nil
         :publishing-function org-html-publish-to-html)))

(defun mkm/fix-title()
  (interactive)
  (insert (replace-regexp-in-string " " "" (upcase-initials (org-entry-get nil "ITEM"))))
  )

(defun mkm/zettel-file-new (x)
  "Create zettel file with name from heading."
  (interactive "sZettel Heading: ")
  (let* (
         (first-char (downcase (substring x nil 1)))
         (rest-str (substring (replace-regexp-in-string " " "" (upcase-initials x )) 1))
         (z (concat (downcase first-char) rest-str)))

    (find-file (concat "~/Documents/org/zk/" z ".md"))
    (insert (concat "# " x "\n\n"))))

(global-set-key (kbd "s-n") 'mkm/zettel-file-new)

(defun mkm/zix-file-new (x)
  "Create zix file with name from heading and zix prefix"
  (interactive "szix Heading: ")
  (let* (
         (first-char (downcase (substring x nil 1)))
         (rest-str (substring (replace-regexp-in-string " " "" (upcase-initials x )) 1))
         (z (concat (downcase first-char) rest-str)))

    (find-file (concat "~/Documents/org/zk/zix_" z ".md"))
    (insert (concat "# " x "\n\n"))))

(global-set-key (kbd "s-N") 'mkm/zix-file-new)

;; use visual-line mode in markdown mode
(defun my-markdown-mode-hook ()
  (visual-line-mode 1)
  (local-set-key (kbd "s-l") 'mkm/link-zk))

(add-hook 'markdown-mode-hook 'my-markdown-mode-hook)

(defun mkm/link-zk ()
  (interactive)
  (ivy-read "ZK File: "
          (directory-files "~/Documents/org/zk" nil "^.*\.md$")
          :action (lambda (file)
                    (save-excursion
                      (with-temp-buffer
                        (insert-file-contents (concat "/Users/michael/Documents/org/zk/" file))
                        (goto-char 1)
                        (setq z (buffer-substring-no-properties 3 (line-end-position))))
                      (insert "[" z "](" file ")")
                      )
                    (end-of-line))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ruby                                                                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(add-to-list 'auto-mode-alist
             '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
(add-to-list 'auto-mode-alist
             '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OSX plist workaround
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;; Allow editing of binary .plist files.
(add-to-list 'jka-compr-compression-info-list
             ["\\.plist$"
              "converting text XML to binary plist"
              "plutil"
              ("-convert" "binary1" "-o" "-" "-")
              "converting binary plist to text XML"
              "plutil"
              ("-convert" "xml1" "-o" "-" "-")
              nil nil "bplist"])

;; It is necessary to perform an update!
(jka-compr-update)


(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
